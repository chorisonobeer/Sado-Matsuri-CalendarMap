# サンプルコード分析結果

## 1. 概要

ユーザー提供のHTMLとJavaScriptサンプルコードを詳細分析し、React + TypeScript実装への移植方針を策定。

## 2. 技術スタック分析

### 2.1. 使用技術
- **HTML5**: セマンティックな構造
- **TailwindCSS**: ユーティリティファーストCSS（CDN版）
- **Font Awesome**: アイコンライブラリ
- **Google Maps Embed API**: 地図表示
- **Vanilla JavaScript**: DOM操作とイベント処理

### 2.2. レイアウト構造
```html
<div class="phone-mockup">           <!-- 414px × 896px -->
  <main class="card-list">           <!-- 上部 2/3 -->
    <!-- イベントカード（2列グリッド） -->
  </main>
  <div class="map-container">        <!-- 下部 1/3 -->
    <iframe>                         <!-- Google Maps -->
    <div id="map-pin-container">     <!-- ピン表示領域 -->
  </div>
</div>
```

## 3. 重要な実装パターン

### 3.1. タップ判定ロジック
```javascript
let lastClickedCardId = null;

function handleCardClick(id) {
    if (lastClickedCardId === id) {
        // 2回目のタップ → モーダル表示
        openEventModal(id);
        lastClickedCardId = null;
    } else {
        // 1回目のタップ → 地図ピン表示
        updateMap(id);
        lastClickedCardId = id;
    }
}
```

**React実装への移植方針**:
- `useState`で`lastClickedCardId`を管理
- `useCallback`でハンドラー関数を最適化

### 3.2. 地図ピン座標計算
```javascript
const mapCenterLat = 38.0195;
const mapCenterLng = 138.2570;
const zoomLevel = 10;

// ピクセル座標変換
const pixelsPerDegreeLat = mapRect.height / (180 / Math.pow(2, zoomLevel - 1));
const pixelsPerDegreeLng = mapRect.width / (360 / Math.pow(2, zoomLevel - 1));

// ピン位置計算
const pinTop = (mapCenterLat - event.latitude) * pixelsPerDegreeLat + mapRect.height / 2;
const pinLeft = (event.longitude - mapCenterLng) * pixelsPerDegreeLng + mapRect.width / 2;
```

**React実装への移植方針**:
- `useRef`で地図要素の参照を取得
- `useEffect`で座標計算とピン更新を実行
- TypeScript型定義で座標データを厳密化

### 3.3. モーダル表示制御
```javascript
function openEventModal(id) {
    // イベント詳細をHTMLで構築
    modalContent.innerHTML = `...`;
    document.getElementById('event-modal').style.display = 'flex';
}

function closeEventModal() {
    document.getElementById('event-modal').style.display = 'none';
}
```

**React実装への移植方針**:
- `useState`でモーダル表示状態を管理
- 条件付きレンダリングでモーダル表示制御
- `useEffect`でESCキー対応を追加

## 4. データ構造分析

### 4.1. イベントデータ構造
```javascript
const events = [
    {
        id: 1,                          // number
        name: "両津花火大会",            // string
        description: "夏の夜空を...",    // string
        location_name: "両津湾",        // string
        address: "新潟県佐渡市両津湊",   // string
        latitude: 38.0805,              // number
        longitude: 138.4503,            // number
        start_date: "2025-08-15",       // string (YYYY-MM-DD)
        end_date: "2025-08-15",         // string (YYYY-MM-DD)
        start_time: "19:30",            // string (HH:MM)
        end_time: "21:00",              // string (HH:MM)
        is_free: true,                  // boolean
        has_parking: true,              // boolean
        has_food_stalls: true,          // boolean
        top_category: "花火",           // string
        tags: ["夏祭り", "花火"],       // string[]
        status: "開催予定",             // string
        image_urls: ["https://..."],    // string[]
        official_link: "https://...",   // string
        highlights: "水中花火の...",     // string
        access_info: "両津港から..."    // string
    }
];
```

### 4.2. 既存システムとの対応関係

| サンプルコード | 既存システム(CSV) | 変換処理 |
|---------------|------------------|----------|
| `id` | `ID` | 数値変換 |
| `name` | `お祭り名` | 直接対応 |
| `description` | `簡単な説明` | 直接対応 |
| `location_name` | `開催場所名` | 直接対応 |
| `address` | `住所` | 直接対応 |
| `latitude` | `緯度` | 数値変換 |
| `longitude` | `経度` | 数値変換 |
| `start_date` | `開始日` | 日付フォーマット変換 |
| `is_free` | `無料か有料か` | boolean変換 |
| `has_parking` | `駐車場の有無` | boolean変換 |
| `top_category` | `上位カテゴリ` | 直接対応 |
| `status` | `開催ステータス` | 直接対応 |
| `image_urls` | `写真URL1-5` | 配列変換 |

## 5. スタイリング分析

### 5.1. 重要なCSSクラス
```css
.phone-mockup {
    width: 414px;
    height: 896px;
    background-color: #ffffff;
    border-radius: 40px;
    display: flex;
    flex-direction: column;
}

.card-list {
    height: calc(896px * 2 / 3);    /* 2/3の高さ */
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 1rem;
    overflow-y: auto;
}

.map-container {
    height: calc(896px * 1 / 3);    /* 1/3の高さ */
    position: relative;
}

.card-image {
    height: 100px;                  /* 固定高さ */
    object-fit: cover;
}
```

### 5.2. SCSS変換方針
- TailwindCSSクラスをSCSS変数とmixinに変換
- 既存のデザインシステムとの統合
- レスポンシブ対応の強化

## 6. パフォーマンス考慮事項

### 6.1. 最適化ポイント
- **画像遅延読み込み**: `loading="lazy"`属性
- **地図読み込み**: iframe遅延読み込み
- **イベントハンドラー**: `useCallback`による最適化
- **レンダリング**: `React.memo`による不要な再描画防止

### 6.2. メモリ管理
- イベントリスナーの適切なクリーンアップ
- 大量データの仮想化（必要に応じて）

## 7. 実装時の注意点

### 7.1. 型安全性
```typescript
interface EventData {
  id: number;
  name: string;
  latitude: number;
  longitude: number;
  // ... 他のフィールド
}

interface MapPinPosition {
  top: number;
  left: number;
}
```

### 7.2. エラーハンドリング
- 地図読み込み失敗時の代替表示
- 座標データ不正時の処理
- ネットワークエラー対応

### 7.3. アクセシビリティ
- キーボードナビゲーション対応
- スクリーンリーダー対応
- 適切なARIA属性の設定

## 8. 次のステップ

1. **既存システム整合性確認**: App.tsxのshopListデータとの対応関係確認
2. **型定義作成**: TypeScript interfaceの詳細定義
3. **コンポーネント設計**: 4つのメインコンポーネントの詳細設計
4. **スタイリング方針**: TailwindCSS → SCSS変換計画
5. **テスト戦略**: 単体テスト・統合テストの計画

---

**重要**: このサンプルコードは要件定義書と完全に一致しており、実装の優秀な参考資料として活用できる。特にタップ判定ロジックと地図ピン座標計算は、そのままReactに移植可能な高品質な実装である。