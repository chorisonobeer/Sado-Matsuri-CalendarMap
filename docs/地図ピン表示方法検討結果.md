# 地図ピン表示方法 技術的検討結果

## 1. 概要

ユーザーからの要望：「CSSを重ねないで、地図のスケールや座標も変更せずにピンだけ表示させる」方法について技術的検討を実施。

## 2. 現在のサンプルコード分析

### 2.1. 現在の実装方式（CSS重ね方式）
```javascript
// 地図上の既存のピンを削除
const pinContainer = document.getElementById('map-pin-container');

// ピンの位置を計算
const pinTop = (mapCenterLat - event.latitude) * pixelsPerDegreeLat + mapRect.height / 2;
const pinLeft = (event.longitude - mapCenterLng) * pixelsPerDegreeLng + mapRect.width / 2;

// ピンの要素を生成して追加
const pin = document.createElement('div');
pin.className = 'map-pin';
pin.style.top = `${pinTop - 30}px`;
pin.style.left = `${pinLeft - 15}px`;
pinContainer.appendChild(pin);
```

**問題点**:
- Google Maps Embed API（iframe）の上にCSS絶対位置でピンを重ねている
- 地図の拡大縮小やドラッグ操作時にピン位置がずれる可能性
- 正式なGoogle Maps APIの機能ではない

## 3. 推奨解決方法：Google Maps JavaScript API + マーカー機能

### 3.1. Google Maps JavaScript API の利点
- **正式なマーカー機能**: `google.maps.Marker` または `AdvancedMarkerElement`
- **アニメーション対応**: `google.maps.Animation.DROP` で上から降下するアニメーション
- **標準アイコン**: Google Maps標準のピンアイコンを使用可能
- **地図操作との連動**: 拡大縮小・ドラッグ時も正確な位置を維持

### 3.2. 実装例（TypeScript）
```typescript
// Google Maps JavaScript API使用
async function initMap(): Promise<void> {
  const { Map } = await google.maps.importLibrary("maps") as google.maps.MapsLibrary;
  const { Marker } = await google.maps.importLibrary("marker") as google.maps.MarkerLibrary;

  const map = new Map(document.getElementById("map") as HTMLElement, {
    center: { lat: 38.0195, lng: 138.2570 }, // 佐渡島中心
    zoom: 10,
    mapId: 'YOUR_MAP_ID' // 必要に応じて
  });

  let currentMarker: google.maps.Marker | null = null;

  // イベント選択時にマーカー表示
  function showEventMarker(event: DashboardEvent) {
    // 既存マーカーを削除
    if (currentMarker) {
      currentMarker.setMap(null);
    }

    // 新しいマーカーを作成（DROP アニメーション付き）
    currentMarker = new Marker({
      position: { lat: event.latitude, lng: event.longitude },
      map: map,
      animation: google.maps.Animation.DROP, // 上から降下アニメーション
      title: event.name
    });
  }
}
```

### 3.3. アニメーション効果
```typescript
// DROPアニメーション：上から降下
marker.setAnimation(google.maps.Animation.DROP);

// BOUNCEアニメーション：跳ねる効果
marker.setAnimation(google.maps.Animation.BOUNCE);
```

## 4. 既存システムとの整合性

### 4.1. 現在のプロジェクト構造
- **既存地図**: Geolonia Maps API使用（`src/App/Map.tsx`）
- **データ構造**: `Pwamap.FestivalData`型
- **座標フィールド**: `緯度`・`経度`（文字列型）

### 4.2. ダッシュボード専用地図の提案
```typescript
// ダッシュボード専用のMapViewコンポーネント
interface MapViewProps {
  selectedEvent: DashboardEvent | null;
  onMarkerClick?: (event: DashboardEvent) => void;
}

const MapView: React.FC<MapViewProps> = ({ selectedEvent, onMarkerClick }) => {
  // Google Maps JavaScript API使用
  // 既存のGeolonia Maps APIとは独立
};
```

## 5. 実装方針の比較

| 方式 | CSS重ね | Google Maps JS API |
|------|---------|-------------------|
| **正確性** | △ 地図操作時にずれる可能性 | ◎ 常に正確な位置 |
| **アニメーション** | △ CSS transition のみ | ◎ DROP/BOUNCE等の標準アニメーション |
| **アイコン** | △ カスタムCSS | ◎ Google Maps標準アイコン |
| **開発コスト** | ◎ 低い | △ API設定が必要 |
| **保守性** | △ 座標計算ロジックが複雑 | ◎ Google公式サポート |

## 6. 推奨実装プラン

### Phase 1: Google Maps JavaScript API導入
1. **API設定**: Google Cloud ConsoleでMaps JavaScript API有効化
2. **MapViewコンポーネント作成**: ダッシュボード専用地図
3. **マーカー機能実装**: DROP アニメーション付き

### Phase 2: 既存システムとの統合
1. **データ変換**: `Pwamap.FestivalData` → `DashboardEvent`
2. **座標型変換**: 文字列 → 数値型
3. **イベントハンドリング**: カードタップ → マーカー表示

### Phase 3: UX向上
1. **カスタムマーカー**: 必要に応じてイベントカテゴリ別アイコン
2. **インフォウィンドウ**: マーカークリック時の詳細表示
3. **クラスター機能**: 複数イベントが近接時の処理

## 7. 結論

**推奨方針**: Google Maps JavaScript APIを使用した正式なマーカー機能の実装

**理由**:
- ユーザー要望（CSS重ねでない、アニメーション、標準アイコン）を完全に満たす
- 地図操作時の位置精度が保証される
- Google公式サポートによる長期的な保守性
- 将来的な機能拡張（クラスター、カスタムアイコン等）が容易

**注意点**:
- Google Maps JavaScript APIの利用料金が発生する可能性
- 既存のGeolonia Maps APIとは別システムとして構築
- API設定とキー管理が必要

---

**次のステップ**: ユーザー承認後、Google Maps JavaScript API導入とMapViewコンポーネント実装を開始